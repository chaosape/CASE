package RouteAggregatorService_Pkg
public
	with CMASI;
    with UXTASK;
    with IMPACT;
    with ROUTE;
    with UxAS_Node_Lib;

	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread RouteAggregatorService; 
		annex agree {**
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
			lemma "num_route_requests_being_serviced >= 0" : sub.num_route_requests_being_serviced >= 0;
			
			--State machine lemmas
			lemma "The value of the state variable corresponds to a 'real' state." :
				(sub.state = sub.IDLE) 
				or (sub.state = sub.PENDING);
			lemma "Only stated transitions are allowed." :
				sub.some_transition or (sub.state = sub.previous_state);
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as observers (without the negation)
			
			--Check that all states are reachable
			lemma "False indicates the IDLE state is reachable" : not (sub.state = sub.IDLE); 
			lemma "False indicates the PENDING state is reachable" : not (sub.state = sub.PENDING);
			
			--Check that all state transitions are reachable
			lemma "False indicates that T_IDLE_TO_PENDING is reachable" : not sub.T_IDLE_TO_PENDING;
			lemma "False indicates that T_PENDING_TO_IDLE is reachable": not sub.T_PENDING_TO_IDLE;
			
			--Check that events are possible
			lemma "False indicates the system is able to produce a route response" : not event(sub.RouteResponse_out);
			lemma "False indicates the system is able to produce a route plan request" : not event(sub.RoutePlanRequest_out);
			lemma "False indicates the system is able to receive a route plan response": not event(sub.RouteRequest_in);
			lemma "False indicates the system is able to receive a route request": not event(sub.RoutePlanResponse_in);
		**};
		 
	end top_level.Impl;	
	
thread RouteAggregatorService
    features
        GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i;
        SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i;
        AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i;
        RouteRequest_in: in event data port route::RouteRequest.i;
        GroundVehicleState_in: in event data port impact::GroundVehicleState.i;
        UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i;
        RoutePlanResponse_in: in event data port route::RoutePlanResponse.i;
        SurfaceVehicleState_in: in event data port impact::SurfaceVehicleState.i;
        TaskPlanOptions_in: in event data port uxtask::TaskPlanOptions.i;
        AirVehicleState_in: in event data port cmasi::AirVehicleState.i;
        ServiceStatus_out: out event data port cmasi::ServiceStatus.i;
        RoutePlanRequest_out: out event data port route::RoutePlanRequest.i;
        AssignmentCostMatrix_out: out event data port uxtask::AssignmentCostMatrix.i;
        RouteResponse_out: out event data port route::RouteResponse.i;
   	annex agree{**
  		-------------------------------------------------------------
  		-- BEGIN STATE MACHINE LOGIC
		-------------------------------------------------------------
		--State constants
 		const IDLE : int = 0;
        const PENDING : int = 1;

		-------------------------------------------------------------
		--State variable
		eq state: int;

		-------------------------------------------------------------
		--State machine support macros		

		eq previous_state: int = prev(state, IDLE);

		eq some_transition: bool = T_IDLE_TO_PENDING
									or T_PENDING_TO_IDLE;

		-------------------------------------------------------------
		--Helper macro for this particular state machine
		eq num_route_requests_being_serviced : int = 
			0 -> 
				(pre(num_route_requests_being_serviced) 
					+ UxAS_Node_Lib.bool_to_int(event(RouteRequest_in)) 
					- UxAS_Node_Lib.bool_to_int(event(RouteResponse_out))
				);
				
		-------------------------------------------------------------	
		--State transition macros
		
		--This is initially false to prevent transition to PENDING on the initial timestep
		--Note: The documentation seems to say we also need to create a table and send the RoutePlanRequest messages
		--  before moving to IDLE. We could possibly introduce another state between IDLE and PENDING for "setup"; 
		--  but since I'm not modeling those details currently, I think it's okay to move to PENDING as soon as we receive
		--  RouteRequest_in.
		eq T_IDLE_TO_PENDING : bool = 
			false -> ((previous_state = IDLE) and event(RouteRequest_in));
		
		--Since we may be servicing multiple requests at a time, we stay in pending until all requests have been 
		-- serviced, in which case we return to IDLE
		eq T_PENDING_TO_IDLE : bool = 
			(previous_state = PENDING) and (num_route_requests_being_serviced = 0);
			
		-------------------------------------------------------------	
		--State machine guarantees
				
		--This guarantee specifies the initial state.
        guarantee "Initial_State": (state = IDLE) -> true;
        
        --This guarantee captures all the "self loops" in shorthand form. 
        -- It is important to state what happens when no transition condition is satisfied.
        -- Otherwise the model checker will allow "spontaneous" transitions.
        guarantee "Self loops": not some_transition => (state = previous_state);
        
        -- Now we write one guarantee for each transition.
        
        --If we had other actions to take on this transition, we would include those in the consequent as well. 
        guarantee "T_IDLE_TO_PENDING_effect" : T_IDLE_TO_PENDING => (state = PENDING);
        
        guarantee "T_PENDING_TO_IDLE_effect" : T_PENDING_TO_IDLE => (state = IDLE);

		-------------------------------------------------------------
		-- END STATE MACHINE LOGIC
		-------------------------------------------------------------
		
		-------------------------------------------------------------
		-------------------------------------------------------------
		-- The guarantees in this section capture correct component behavior.
		-- The set is still not complete though.
		
		guarantee "Only produce a route response when previous state was PENDING": 
			event(RouteResponse_out) => (previous_state = PENDING);
	
		guarantee "Only produce a route plan request when the previous state was PENDING": 
			event(RoutePlanRequest_out) => (previous_state = PENDING);	

		-- Should we pick a time window so that we can state the following property? 
		--   RouteRequest_in => within X we get a RouteResponse_out with a matching ID
		--   We would need to assume that the route planners respond in a timely manner
		--   in order to guarantee that.

		-------------------------------------------------------------
		-- Guarantees that need arrays, or records mimicking arrays, to formally express.
		
		-- The locations and destinations (first and last waypoints) of the route plans in the responses should match the requests, or an error should be produced.
		-- This is something the route planners should guarantee, and we could check that the originator of the RouteRequst receives 
		-- routes that satisfy this if we could guarantee that this RouteAggregator Service passed on the routes from the planners without
		-- modifying them, but we can't do that without building the array of responses or changing the data structure (interface)
		-- somehow.	
		
		--Think of these Boolean variables as a predicates
		
		eq route_response_consists_of_route_plan_responses_received : bool;
		guarantee "The routes in RouteResponse_out are the route plan responses received." :
			route_response_consists_of_route_plan_responses_received; --guarantee that this predicate is true
		
		eq route_plan_request_sent_for_each_vehicleID : bool;	
		guarantee "For each vehicle ID in the VehicleID array of the route request, a route plan request message is sent
		    with a matchine Vehicle ID (and the rest of the contents the same)":
		    route_plan_request_sent_for_each_vehicleID; --guarantee that this predicate is true
		
		-------------------------------------------------------------
		-- The guarantees below this line depend on some internal state. That is difficult to
		--  express for a RouteAggregatorService that can service an arbitrary number of 
		--  requests at a time. We would be forced to fix the number it can serve to some max
		--  for modeling purposes. Not sure we want to do that.
		--  Q for Sean/Derek: Does it really serve an arbitrary number or is there a max?
		--	A from Sean: It's variable, depending on number of requests you make.
		
		-- Note: I do have a formal version of these guarantee in RouteAggregatorService_OneRequestAtATime
		--
		-- Tony: Maybe this can be done with variables for current request and associated route plan request.
		-- Jen: The new version below does just that. (Thanks, Tony!)
		
		--The route request for which we are making new route plan requests
		eq RouteRequest_being_serviced : route::RouteRequest.i; 
		
		guarantee "Contents of route plan requests match contents of the associated route request (except VehicleID and RequestID)":
				event(RoutePlanRequest_out) =>
				((RoutePlanRequest_out.AssociatedTaskID = RouteRequest_being_serviced.AssociatedTaskID)
					and (RoutePlanRequest_out.OperatingRegion = RouteRequest_being_serviced.OperatingRegion)
					and (RoutePlanRequest_out.RouteConstraints = RouteRequest_being_serviced.RouteConstraints)
					and (RoutePlanRequest_out.IsCostOnlyRequest = RouteRequest_being_serviced.IsCostOnlyRequest)
				);
		

		-- We may want to add a guarantee about sending the route plan requests within some
		--  timeframe. For now, as modeled, this service could sit on them forever. 
		
		eq produce_route_response_once_all_route_plan_responses_have_been_received : bool;
		guarantee "Produce route response output once all route plan responses have been received" : 
			produce_route_response_once_all_route_plan_responses_have_been_received;
		
		eq RouteRequest_being_responded_to : route::RouteRequest.i; 
		
		guarantee "Response ID in the route response should match the ID in the associated route request." :
			event(RouteResponse_out) => (RouteResponse_out.ResponseID = RouteRequest_being_responded_to.RequestID);
		
		-- Q: Is the ResponseID in the route plan responses enough to ensure the message is the response we're expecting? 
		-- Do we have any system-level guarantees about uniqueness of these IDs? 
			
		------------------------------------------------------------
		-- Below is some Q&A. Discussion held 6/13/17 with Jen, Aaron, Sean, Ben R., and John B. 
		
		-- Q: What will the top-level UxAS use from this? It doesn't have visibility into the internal state... 
		-- John: Modeling the state makes sense if we have a system-level guarantee that references it.
		-- Ben: Higher level req may be if all responses are received, response is sent out.
		-- John: We could try to figure out our system-level reqts first and model the Wiki more coarsely.
		
		-- Q (Philosophical): Should component contracts include only what we need for architectural level reasoning,
		--  or should the contracts be sufficiently detailed so that any component satisfying the contract will
		--  result in a correctly functioning system? Or would one argue that these are in fact the same?
		-- John: In general, a component contract should have at least enough info to prove system-level reqts.
		-- 	Component reqts need to trace to some system reqt.
		-- Ben: But sometimes we build components out of context. Maybe some are identified for "plug-and-play." Those may
		--  be over-designed.
		-- Aaron: Contracts should ensure that a replacement component gives us the same functionality that we had 
		--  previously. 
		 
		--  Currently, my contracts on this component are not nearly sufficient to ensure correctness. The output
		--  messages could be jibberish. Even if I require the response ID to match the request ID, the
		--  rest of the information could be garbage.

	**};
end RouteAggregatorService;

end RouteAggregatorService_Pkg;