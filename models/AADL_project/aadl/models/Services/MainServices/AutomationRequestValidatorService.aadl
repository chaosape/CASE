package AutomationRequestValidatorService_Pkg
public
    -- Include DataTypes
    with CMASI;
    with UXTASK;
    with IMPACT;

    -- Includes
	with ServiceBase_Pkg;
    
    -- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		features
			AutomationRequest_in : in event data port cmasi::AutomationRequest.i;
			UniqueAutomationResponse_in : in event data port uxtask::UniqueAutomationResponse.i;
		annex agree {**
			eq event_AutomationRequest_in : bool = event(AutomationRequest_in);
			assume "AutomationRequest_in is assumed to occur sporadically with an inter arrival time no sooner than 3ms.": 
				condition event_AutomationRequest_in occurs sporadic with IAT 0.003;
				
			eq event_UniqueAutomationResponse_in : bool = event(UniqueAutomationResponse_in);
			assume "UniqueAutomationResponse_in is assumed to occur sporadically with an inter arrival time no sooner than 2ms" :
				condition event_UniqueAutomationResponse_in occurs sporadic with IAT 0.002;
			
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread AutomationRequestValidatorService; 
		connections
			conn0 : port UniqueAutomationResponse_in -> sub.UniqueAutomationResponse_in;
			conn1 : port AutomationRequest_in -> sub.AutomationRequest_in;
		annex agree {**
			-- These lemmas could be captured in SpeAR as oberservers (without the negation)
			lemma "False indicates the IDLE state is reachable" : sub.state != sub.IDLE; 
			lemma "False indicates the BUSY state is reachable" : sub.state != sub.BUSY; --NOTE: initially found this was unreachable
			
			lemma "True indicates we have enumerated all states in the reachability observers" :
				sub.state = sub.IDLE or
				sub.state = sub.BUSY;	
				
			lemma "False indicates idle_to_busy transition is reachable" : 
           		 not sub.idle_to_busy;
           		 
           	lemma "False indicates busy_to_idle transition is reachable" : 
           		 not sub.busy_to_idle;	
           		 
           	lemma "True if only stated transitions are executed (no missing transitions)." :
                sub.some_transition or sub.state = sub.previous_state;	
				
			lemma "True indicates the queue can never go negative" : 
            	sub.numAutomationRequestsInQueue >= 0;
            lemma "False indicates the queue can potentially be greater than 0" : 
            	sub.numAutomationRequestsInQueue = 0;
            	
		**};
	end top_level.Impl;	
	
    
    thread AutomationRequestValidatorService extends ServiceBase_Pkg::ServiceBase
        features
            TaskInitialized_in: in event data port uxtask::TaskInitialized.i;
            KeepOutZone_in: in event data port cmasi::KeepOutZone.i;
            SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i;
            AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i;
            AreaOfInterest_in: in event data port impact::AreaOfInterest.i;
            AutomationRequest_in: in event data port cmasi::AutomationRequest.i;
            GroundVehicleState_in: in event data port impact::GroundVehicleState.i;
            TaskAutomationRequest_in: in event data port uxtask::TaskAutomationRequest.i;
            UniqueAutomationResponse_in: in event data port uxtask::UniqueAutomationResponse.i;
            PointOfInterest_in: in event data port impact::PointOfInterest.i;
            RemoveTasks_in: in event data port cmasi::RemoveTasks.i;
            Task_in: in event data port cmasi::Task.i;
            OperatingRegion_in: in event data port cmasi::OperatingRegion.i;
            GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i;
            AirVehicleState_in: in event data port cmasi::AirVehicleState.i;
            SurfaceVehicleState_in: in event data port impact::SurfaceVehicleState.i;
            KeepInZone_in: in event data port cmasi::KeepInZone.i;
            ImpactAutomationRequest_in: in event data port impact::ImpactAutomationRequest.i;
            LineOfInterest_in: in event data port impact::LineOfInterest.i;
                    --note that the code does not actually subscribe to "ServiceStatus" currently
            --TODO: derek suggests ServiceStatus_in is how error messages are indicated to the service, but we currently do not use it
            ServiceStatus_in: in event data port cmasi::ServiceStatus.i; 
                    --the source code subscribes to all descendants of task:
            SearchTask_in: in event data port cmasi::SearchTask.i;
            AreaSearchTask_in: in event data port cmasi::AreaSearchTask.i;
            LineSearchTask_in: in event data port cmasi::LineSearchTask.i;
            LoiterTask_in: in event data port cmasi::LoiterTask.i;
            MustFlyTask_in: in event data port cmasi::MustFlyTask.i;
            PointSearchTask_in: in event data port cmasi::PointSearchTask.i;
            ServiceStatus_out: out event data port cmasi::ServiceStatus.i;
            ImpactAutomationResponse_out: out event data port impact::ImpactAutomationResponse.i;
            AutomationResponse_out: out event data port cmasi::AutomationResponse.i;
            TaskAutomationResponse_out: out event data port uxtask::TaskAutomationResponse.i;
            UniqueAutomationRequest_out: out event data port uxtask::UniqueAutomationRequest.i;
        properties
            Dispatch_Protocol => Sporadic;
            
            
        annex agree {**
        --Questions: 
            --Is the system idle when waiting for a response?
                --Busy defined with respect to "servicing" a request, not the queue size? 
            --Does the system move on to the next task before receiving a response? 
            --Is it possible to recieve a response that does not match the request? 
                --Is this an error? 
            --What is an error message?
                
            --States
            const IDLE : int = 0;
            const BUSY : int = 1;
            
            --TODO: possible third or intermediate state? 
            -- All vehicles requested exist, task requested exists, flight regions actually exist. 
            
            --previous received an airvehicle ID, airvehicle state
                --AirVehicleConfiguration_in and AirVehicleState_in
            --task requested exists
                --TaskInitialized_in
            -- regions
                -- OperatingRegion_in
                -- KeepInZone_in
                -- KeepOutZone_in
        
        -------------------------------------------------------------
        --State machine support macros
            eq previous_state: int = prev(state,IDLE);
            eq some_transition: bool = idle_to_busy
                                    or busy_to_idle;
        -------------------------------------------------------------
        
        ---------------- state transitions ----------------
            eq idle_to_busy : bool = false -> 
                (previous_state = IDLE and 
                pre(event(AutomationRequest_in)) and  
                pre(taskVehicleOrRegionIsDefined));
            
            eq busy_to_idle : bool = false -> 
                (previous_state = BUSY and 
                pre(dequeue_trigger) and 
                --When all queued requests are serviced (the queue is 0)
                -- and the initial un-queued request is also serviced
                --Using this variable to avoid modeling a queue with a -1 size
                --and to simplify the state change condition
                pre(all_requests_serviced)); 
        ---------------- end state transitions ----------------

			eq all_requests_serviced : bool;

            eq expected_UniqueAutomationResponse_received : bool = 
            	event(UniqueAutomationResponse_in) and 
                	UniqueAutomationResponse_in.ResponseID = cached_unique_automation_request_id and 
                	not uniqueAutomationRequestErrorMessageRecieved;
                
            eq dequeue_trigger : bool = 
                expected_UniqueAutomationResponse_received or
                timer_threshold_reached or 
                received_error_message;
                
            eq timer_threshold_reached : bool = 
                timeout_option and 
                timer>=timeout_threshold;
                
            eq received_error_message : bool = 
                --TODO: Derek is going to update the spec to have a unique automation error response in
                --check the error response to match the cached ID, if matched there is an error. 
                event(UniqueAutomationResponse_in) and 
                UniqueAutomationResponse_in.ResponseID = cached_unique_automation_request_id and
                uniqueAutomationRequestErrorMessageRecieved; --represents a flag indicating error for now
                
            eq timer : int;
            eq timeout_threshold : int;
            eq timeout_option : bool;
            eq state : int;
            eq cached_unique_automation_request_id : int;
            
            const SERVICE_TYPE_ERROR_SIGNAL : int = 2;
            
            eq timer_reset: bool = 
                (event(UniqueAutomationRequest_out) or --Timer starts once we ask for a response (make a request)
                state=IDLE or 						  -- Timer is always 0 in the IDLE state
                (event(UniqueAutomationResponse_in) and 
                	UniqueAutomationResponse_in.ResponseID  = cached_unique_automation_request_id));  --The expected response is received
            
            -- a non-deterministic variable used to model whether or not 
            -- the requested task, vehicle, or operating region has been defined.
            -- AWF (20170620): This should be temporary until other components are generated to support a more precise description
            eq taskVehicleOrRegionIsDefined : bool;
            
            eq uniqueAutomationRequestErrorMessageRecieved : bool; --????

            eq numAutomationRequestsInQueue : int;
            
            guarantee "Self loops": not some_transition => (state = previous_state);
                
            guarantee "Initially the task queue is empty" :
                (numAutomationRequestsInQueue = 0) -> true;
    
            guarantee "Implied Spec: Initially, the service is idle" :
                (state = IDLE) -> true;
                
            guarantee "[in IDLE the numAutomationRequestsInQueue is 0]" :
                state = IDLE =>
                    numAutomationRequestsInQueue = 0;
            
            --TODO make error message a new variable. 
            
            --TODO: check request resource definition instead of non deterministic boolean? 
            --TODO: Derek has suggested how error messages are modeled here may not be correct. We may need to receive ServiceStatus_in
             --but the current code does not address this. There is apparently ongoing work on how to handle error messages.
             --This guarantee is probably wrong, and will need to be reassessed as error handling is concretized. 
            guarantee "[Modified this guarantee to address the only cases in which an error message is to be sent out].
            	if automation request is received and the requested resource has not been defined then produce an error
                [In the busy state, if an error message is received, send an error message as a ServiceStatus_out]" : 
                (event(AutomationRequest_in) and not taskVehicleOrRegionIsDefined) or
                	(state = BUSY and received_error_message) <=>
                    --TODO: derek will add automation request
                    event(ServiceStatus_out) and 
                    ServiceStatus_out.StatusType = SERVICE_TYPE_ERROR_SIGNAL; 
                    --event(AutomationResponse_out); Addressed by another guarantee now
                    --TODO: apparently the code sets the status type to "information" rather than "error"
                
            --Note: the original wording of this guarantee implies the unique automation request is only sent
            --out when the system is IDLE. I am manually altering the original "spec" to speak to what I believe
            --was intended
            --Note: the wording "immediately" seems to imply it is ok to immediately raise the event instead of using the
            --"eventually" idiom. 
            guarantee "if automation request is received and resource is defined produce unique automation request.
            If in the idle state, this service will immediately publish the UniqueAutomationRequest message and transition to the busy state.": true ->
                 idle_to_busy =>
                 	state = BUSY and 
                    event(UniqueAutomationRequest_out) and 
                    cached_unique_automation_request_id = UniqueAutomationRequest_out.RequestID; --Used for subsequent specs
           
           guarantee "[ADDED SPEC] cached_unique_automation_request_id does not change if the two conditions under which it can change are both not currently triggered. 
           These conditions are implied in other guarantees.":
           		(not idle_to_busy and  
           		 not(state = BUSY and 
           			dequeue_trigger and 
           			pre(numAutomationRequestsInQueue) >0)) =>
           				cached_unique_automation_request_id = pre(cached_unique_automation_request_id);
            		
            --NOTE: the original (first) request made when the service is IDLE is not queued
            guarantee "[NOTE: a spec to fully specify how the queue changes. Putting it all in one place
            	to be able to easily and clearly specify when the numAutomationRequestsInQueue remains constant between time steps.]":
                  state = BUSY =>
                    (if event(AutomationRequest_in) and taskVehicleOrRegionIsDefined then
                        numAutomationRequestsInQueue = pre(numAutomationRequestsInQueue) + 1
                    --[Implied Requirement: in the busy state, process next task in the queue, if one exists, when a dequeue_trigger occurs]
                    else if dequeue_trigger and pre(numAutomationRequestsInQueue) >0 then
                    	numAutomationRequestsInQueue = pre(numAutomationRequestsInQueue) - 1 and
                    	event(UniqueAutomationRequest_out) and  --Send out next request in the queue
                        cached_unique_automation_request_id = UniqueAutomationRequest_out.RequestID
                    --[when all requests have been serviced including all queued, decrement the queue again to indicate
                    --	a transition to IDLE is warranted.]
                    else if dequeue_trigger and numAutomationRequestsInQueue = 0 then
                    	all_requests_serviced = true
                   	else
                        numAutomationRequestsInQueue = pre(numAutomationRequestsInQueue));
          
          	guarantee "[Explicitly save state on all requests serviced in all time steps, redundant with the above gaurantee]":
          		if state= BUSY and dequeue_trigger and numAutomationRequestsInQueue = 0 then
                    all_requests_serviced = true
                else
                	all_requests_serviced = false; 
                	
          	--NOTE: added to make sure the model checker will not send out UniqueAutomationRequest_out unless
          	--within the specified conditions. 
         	guarantee "[Explicitly specifying the only conditions where UniqueAutomationRequest_out. This makes
         		some other guarantees redundant.]" : 
         			((state = BUSY and dequeue_trigger and pre(numAutomationRequestsInQueue) >0) or idle_to_busy) <=>
         				event(UniqueAutomationRequest_out);
                   
--              pre(event(TaskAutomationRequest_in) and taskVehicleOrRegionIsDefined) =>
--                  state = BUSY and numTasksInQ = pre(numTasksInQ) + 1;
                    -- AWF (20170620): Wouldn't we want pre(state) = IDLE otherwise we are asking the previous of a bool evaluation
--                  if pre(state = IDLE) then 
--                      event(UniqueAutomationRequest_out) and state = BUSY --and numTasksInQ = 0
--                  else --state = BUSY
--                     state = BUSY and numTasksInQ = pre(numTasksInQ) + 1;
                       
            
            --Note: unless timeout_option is fixed, the model checker can switch it on and off arbitrarily, allowing this behavior for now
            guarantee "Service includes an optional timeout. When a UniqueAutomationRequest is published, a timer begins. 
            	[When the timeout option is 'on' increment the timer (currently unspecified how per time step) unless a timer
            		reset is received, in which case the timer is reset to 0 on the next time step]" : true ->
                timeout_option => 
                    (if pre(timer_reset) then
                        timer = 0
                    else 
                        timer > prev(0,timer)); --Note: forcing an incrementing timer (unspecified increment) for now
                        
                        
            --TODO: is this service validating "requests" while queued or only when requests are being actively serviced.
            
            guarantee "If the queue is empty, this service transitions back to the idle state. 
            [Implied, that the transition occurs also based on a response, timeout, or error message, i.e., a dequeue trigger]" :
                busy_to_idle => 
                    state = IDLE;
                
             --TODO: the guarantee overly simplifies the AutomationResponse_out, the content of the message will need to 
             --be adjusted depending on the type of message (error or ordinary response) in correspondence to the original request (TBD)      
            guarantee "[In the busy state] When this service receives either an error message 
            (indicating that the UniqueAutomationRequest cannot be fulfilled) or 
                a corresponding UniqueAutomationResponse, it will publish the same message [As an AutomationResponse_out]. 
            [ADDENDUM: AutomationReponse_out should only be sent out in the event of an erroneous request or 
            		 when a dequeue_trigger is raised in the BUSY, which also includes the possibility of a timeout]" : 
                ((state = BUSY and dequeue_trigger) or (event(AutomationRequest_in) and not taskVehicleOrRegionIsDefined)) <=> 
                    event(AutomationResponse_out); --TODO: correspond this response with the request in terms of message contents
                    
--          --Cannot formalize in AGREE (unlesse I create a counter)
--          guarantee "The request ID of unique automation responses are unique" :
--              true;
--              
--          --Not sure if there is a way to model this property in agree
--          guarantee "tasks are fed into 'the system' one at a time" : 
--              true; --What was meant was to mean "the queue", might not be necessary
        **};
    end AutomationRequestValidatorService;

    
end AutomationRequestValidatorService_Pkg;
