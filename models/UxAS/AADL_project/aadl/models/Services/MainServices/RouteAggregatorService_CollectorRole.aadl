package RouteAggregatorService_CollectorRole_Pkg
public
	with CMASI;
    with UXTASK;
    with IMPACT;
    with ROUTE;

    with TB_SYS;
    
	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		features
			UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i; 
		
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread RouteAggregatorService_CollectorRole; 
		connections
			conn00: port UniqueAutomationRequest_in -> sub.UniqueAutomationRequest_in;
		
		 
	end top_level.Impl;	
	
thread RouteAggregatorService_CollectorRole
    features
        GroundVehicleState_in: in event data port impact::GroundVehicleState.i; 
        AirVehicleState_in: in event data port cmasi::AirVehicleState.i; 
        SurfaceVehicleState_in: in event data port impact::SurfaceVehicleState.i;
        
        UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i; 
        RoutePlanResponse_in: in event data port route::RoutePlanResponse.i; --keep
        TaskPlanOptions_in: in event data port uxtask::TaskPlanOptions.i; 
        ServiceStatus_out: out event data port cmasi::ServiceStatus.i; --This port is not mentioned in the Wiki. Per Derek, it is used for error reporting (or at least can be used for that.)
        RoutePlanRequest_out: out event data port route::RoutePlanRequest.i; 
        AssignmentCostMatrix_out: out event data port uxtask::AssignmentCostMatrix.i; 
        properties
            Dispatch_Protocol => Sporadic;
          TB_SYS::Is_External => true;
          Priority => 253;
          TB_SYS::Thread_Type => Active;
          Compute_Execution_Time => 10 us .. 100 us;       
end RouteAggregatorService_CollectorRole;

end RouteAggregatorService_CollectorRole_Pkg;