package AssignmentTreeBranchBoundBase_Pkg
public
    -- Include DataTypes
	with CMASI;
    with UXTASK;
--    with PlanBuilderService_Pkg;

    -- Includes
	with ServiceBase_Pkg;
    
    -- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	-- This top-level system also is used to check timing properties between the 
	-- AssignmentTreBranchBoundBase and the PlanBuilderService. 
	-- We should move this top_level system  in the future to another file to make the AssignmentTreeBranchBoundBase
	-- cleaner and more cohesive. 
	process top_level
		features
			TaskPlanOptions_in: in event data port uxtask::TaskPlanOptions.i;
			AssignmentCostMatrix_in: in event data port uxtask::AssignmentCostMatrix.i;
			TaskAssignmentSummary_out: out event data port uxtask::TaskAssignmentSummary.i;
			UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i;
			
--			--PlanBuilder features (outputs)
--			TaskImplementationRequest_out : out event data port uxtask::TaskImplementationRequest.i;
			
		annex agree {**
				
			eq state_counter : int = (0->(pre(state_counter)+1));
			
			
			------------------------------------------	
			--Assumptions for AssignmentTreeBranchBound	
				
			eq event_UniqueAutomationRequest_in : bool = event(UniqueAutomationRequest_in);
			assume "UniqueAutomationRequest_in occurs every 1s":
				condition event_UniqueAutomationRequest_in occurs each 1.0;
				
			eq event_TaskPlanOptions_in : bool = event(TaskPlanOptions_in);
        	--Extra assumption for assignment tree, event(TaskPlanOptions_in) must have an assumed timing bounds to ensure timing properties
        	assume "TaskPlanOptions_in must occur with some frequency otherwise the service could wait forever, assuming 1 second for now":
        		condition event_TaskPlanOptions_in occurs each 1.0;
				
			eq event_AssignmentCostMatrix_in : bool = event(AssignmentCostMatrix_in);
			eq event_expected_acm : bool; 
			assume "AssignmentCostMatrix_in is assumed to occur sporadically with an inter arrival time no sooner than 2000ms" :
				--condition event_AssignmentCostMatrix_in occurs each 2.0;--1.6;--sporadic with IAT 1.6;
				condition event_expected_acm occurs each 2.0;
			
			assume "UniqueAutomationRequest_in must provide a TaskList of size greater than 0 and less than or equal to 10":
        		event(UniqueAutomationRequest_in) => 
        			UniqueAutomationRequest_in.OriginalRequest.TaskListSize > 0 and UniqueAutomationRequest_in.OriginalRequest.TaskListSize <= 10;
        	
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread AssignmentTreeBranchBoundBase; 
--			sub2 : thread PlanBuilderService_pkg::PlanBuilderService;
		connections
			conn0 : port AssignmentCostMatrix_in -> sub.AssignmentCostMatrix_in;
--			conn1 : port sub.TaskAssignmentSummary_out -> sub2.TaskAssignmentSummary_in;
			conn1a : port sub.TaskAssignmentSummary_out -> TaskAssignmentSummary_out ;
			conn2 : port UniqueAutomationRequest_in -> sub.UniqueAutomationRequest_in;
--			conn3 : port sub2.TaskImplementationRequest_out -> TaskImplementationRequest_out;
			conn4 : port TaskPlanOptions_in -> sub.TaskPlanOptions_in;
		annex agree {**
				
			-- These lemmas could be captured in SpeAR as oberservers (without the negation)
			lemma "False indicates the INIT state is reachable" : sub.state != sub.IDLE; 
			lemma "False indicates the IDLE state is reachable" : sub.state != sub.WAIT; 

			lemma "True indicates we have enumerated all states in the reachability observers" :
				sub.state = sub.IDLE or
				sub.state = sub.WAIT; 
				
			lemma "False indicates idle_to_wait transition is executable/reachable" : 
           		 not sub.idle_to_wait;
           	
           	lemma "False indicates wait_to_idle transition is executable/reachable" : 
           		 not sub.wait_to_idle;
           		 
           	lemma "True if only stated transitions are executed (no missing transitions)." :
                sub.some_transition or sub.state = sub.previous_state;		
		**};
	end top_level.Impl;	
	
	
	thread AssignmentTreeBranchBoundBase extends ServiceBase_Pkg::ServiceBase
        features
            TaskPlanOptions_in: in event data port uxtask::TaskPlanOptions.i;
            AssignmentCostMatrix_in: in event data port uxtask::AssignmentCostMatrix.i;
            UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i;
            ServiceStatus_out: out event data port cmasi::ServiceStatus.i;
            TaskAssignmentSummary_out: out event data port uxtask::TaskAssignmentSummary.i;
            
      	annex agree
      	{**
      		
      		--TODO: added this guarantee last minute. Appears to be necessary in order to hook this component
      		--up to the PlanBuilderService, even if you assume it is the case, the prover will have trouble unless
      		--this guarantee is explicitly provided. Further experimentaiton with the assumption is necessary. 
      		--This guarantee should be relocated to a better position in the spec, and the MAX number should be
      		--set in a way that is easily visible from a higher level parent system (e.g., use an assumption?)
      		 guarantee "TaskAssignmentSummary_in must provide a TaskList of size greater than 0 and less than or equal to 10":
        		event(TaskAssignmentSummary_out) => 
        			TaskAssignmentSummary_out.TaskListSize > 0 and TaskAssignmentSummary_out.TaskListSize <= 10;
			
			
      		eq state : int;
       		
       		--Task States
       		const IDLE : 				int = 1;
       		const WAIT : 				int = 2;

       	-------------------------------------------------------------
		--State machine support macros
			eq previous_state: int = prev(state,IDLE);
			eq some_transition: bool = idle_to_wait
										or wait_to_idle; 
		-------------------------------------------------------------		

		--------------------------State Transition Predicates-----------------------------------
      		
      		--Upon reception of a UniqueAutomationRequest, this service enters the wait state 
      		eq idle_to_wait : bool =  (false ->
      			(previous_state = IDLE and 
      			pre(event(UniqueAutomationRequest_in))));
      		--The results of the optimization are packaged into the TaskAssignmentSummary and published, 
      		--at which point this service returns to the idle state.
      		eq wait_to_idle : bool = (false ->
      			(previous_state = WAIT and
      			pre(event(TaskAssignmentSummary_out))));
      			
      		-- Other internal transitions --
      		
      		eq send_task_assignment_summary : bool = (false ->
      			(state = WAIT and 
      			expectedAssignmentCostMatrixRecieved and
      			allExpectedTaskOptionsReceived));
      			
      		--NOTE: CANNOT FORMALIZE WITHOUT ARRAY SUPPORT (NO WAY TO TIE VARIABLE TO INPUT PORTS)	
      		--True if while in the wait state, all taskoptions are received for all tasks in the request
      		--TaskOptions must match the UniqueAutomationRequest ID to be valid. 
      		--According to Derek, option tasks may come in that overwrite existing tasks. This may
      		--in the future be considered an error, but currently if it where to happen they are allowing the overwrite. 
      		eq allExpectedTaskOptionsReceived : bool = (false ->
        		(if state = IDLE then
        			false --reset in IDLE
        		else if state = WAIT and current_total_task_options_to_recieve = current_task_options_recieved_counter then
        			true
        		else
        			--Once true, retain the value until reset by the IDLE state
        			--Effectively, ignore any further TaskOptions_in after the target number is reached
        			pre(allExpectedTaskOptionsReceived))); 
        			 
        	eq expectedAssignmentCostMatrixRecieved : bool = (false ->
      			(if state = IDLE then
      				false --reset when in the IDLE state
      			else if state = WAIT and event(AssignmentCostMatrix_in) and 
      				 	AssignmentCostMatrix_in.CorrespondingAutomationRequestID = curUniqueAutomationRequestID then
      				true 
      			else
      				--Once True retain the value until reset by the IDLE state
      				pre(expectedAssignmentCostMatrixRecieved)));
      		
      		eq curUniqueAutomationRequestID : int = 
      			(if state = IDLE and event(UniqueAutomationRequest_in) then
      				UniqueAutomationRequest_in.RequestID
      			else
      				pre(curUniqueAutomationRequestID));
      		
      		 --TODO: ASK DEREK: arbitrary number chosen here
        	const MAX_TASKS : int = 10;
        			 
        	eq current_total_task_options_to_recieve : int = (
        		(if state = IDLE and event(UniqueAutomationRequest_in) then
        			UniqueAutomationRequest_in.OriginalRequest.TaskListSize
        		else
        			pre(current_total_task_options_to_recieve)));
        		
        	eq current_task_options_recieved_counter : int = (
        		(if state = IDLE and event(UniqueAutomationRequest_in) then
        			0
        		else if state = WAIT and event(TaskPlanOptions_in) then
        			--As per an assumption stipulated below, we cannot match IDs for TaskPlanOptions_in
        			--due to limitations with arrays, so we are currently assuming any TaskPlanOption_in
        			--is "expected";
        			pre(current_task_options_recieved_counter) + 1 
        		else
        			pre(current_task_options_recieved_counter)));
        	
        	--TODO: is there a way to remove this assumption and place it in the parent?
        	--The purpose of this assumption is to ensure it is OK to use MAX_TASKS as an upper bound. 
        	--This assumption may not be necessary (the timing guarantees and other component specs may
       		--may be all that is needed to prevent hanging in one state). The purpose of having the 
       		--assumption here is to better define what would otherwise be unbound predicates and to avoid
       		--potential issues with the unbound nature of the predicate causing timing issues.
       		--Intuitively, the lack of upper bounds may suggest that system-level timing properties 
       		--cannot be proven, but there may be constraints and properties that somehow obviate the need for 
       		--assumptions like this. 
        	assume "UniqueAutomationRequest_in must provide a TaskList of size greater than 0 and less than or equal to 10":
        		event(UniqueAutomationRequest_in) => 
        			UniqueAutomationRequest_in.OriginalRequest.TaskListSize > 0 and UniqueAutomationRequest_in.OriginalRequest.TaskListSize <= MAX_TASKS;
        	
        	assume "[INFORMAL ASSUMPTION PLACEHOLDER] Due to limitations in the formal analysis tools, there is no way to verify incoming task plan options
        		are expected, i.e., for the expected tasks as listed in the unique automation request. We therefore must assume that all task options are 
        		in fact expected and unique, thus allowing the model to simply count requests. There is no way of formalizing this assumption so it is left
        		here as a placeholder so this assumption is not forgotten or implicit.":
        			true;
      		
      		guarantee "Self loops": not some_transition => (state = previous_state);
      	
      		--NOTE: the transition occurs on the time step after receiving the UniqueAutomationRequest
      		guarantee "[In the idle state] Upon [changed to 'after'] reception of a UniqueAutomationRequest, this service enters the wait state ": 
      			idle_to_wait =>
      				state = WAIT;
      		
--      			if idle_to_wait then
--      				state = WAIT and
--      				curUniqueAutomationRequestID = UniqueAutomationRequest_in.RequestID
--      			else
--      				curUniqueAutomationRequestID = pre(curUniqueAutomationRequestID);
      			
      		--NOTE: THe following 4 guarantees should not be necessary (should be handled by definition of the equations), 
      		--but were necessary to make the example realizable. 	
      			
      		guarantee "[Upon receiving a UniqueAutomationRequest_in in the IDLE state, the ID is cached, 
      				the total task options to receive variable is set and the options received counter is reset]":
      			if state = IDLE and event(UniqueAutomationRequest_in) then
      				curUniqueAutomationRequestID = UniqueAutomationRequest_in.RequestID and
      				current_total_task_options_to_recieve = UniqueAutomationRequest_in.OriginalRequest.TaskListSize and
      				current_task_options_recieved_counter = 0
      			else
      				curUniqueAutomationRequestID = pre(curUniqueAutomationRequestID) and
      				current_total_task_options_to_recieve = pre(current_total_task_options_to_recieve);
      				
      		guarantee "[ADDED GUARANTEE - made under the assumption we can rely on simple counting of options received, see assumption above]:
      		 All expected tasks options are received when the total recieved unique task options equals to the total expected.":
      			(state = WAIT and current_total_task_options_to_recieve = current_task_options_recieved_counter) => 
      				allExpectedTaskOptionsReceived;
      				
      		guarantee "[ADDED GUARANTEE - made under the assumption we can rely on simple counting of options received, see assumption above]
      			When a TaskPlanOptions_in is received in the WAIT state, increment the received task options counter":
      			(state = WAIT and event(TaskPlanOptions_in)) =>
      				current_task_options_recieved_counter = pre(current_task_options_recieved_counter)+1;
      				
      		guarantee "[ADDED GUARANTEE] If not in WAIT and receiving a TaskPlanOptions_in or in IDLE and receiving UniqueAutomationRequest_in
      			the received task options counter remains constant" :
      			(not (state = IDLE and event(UniqueAutomationRequest_in)) and 
      					not ((state = WAIT and event(TaskPlanOptions_in)))) =>
      				current_task_options_recieved_counter = pre(current_task_options_recieved_counter);
      				
      	     --NOTE: although there is an expectation about the ordering in which the RouteAggregatorService sends out
      		--the AssignmentCostMatrix relative to receiving Taskoptions, there is no intrinsic need to assume this ordering here (verified with Derek).
      		--We instead allow the TaskOptions and Matrix to come in in any order. Upon receiving the requisite task and matrix the summary is sent out. 
      		guarantee "Upon receiving the AssignmentCostMatrix (which should be received strictly after the TaskPlanOptions
      			due to the behavior of the RouteAggregatorService), this service conducts the branch-and-bound search to determine 
      			the proper ordering and assignment of Tasks to vehicles. The results of the optimization are packaged into the TaskAssignmentSummary":
      			send_task_assignment_summary <=> event(TaskAssignmentSummary_out);
--      			if send_task_assignment_summary then
--      				event(TaskAssignmentSummary_out)
--      			else
--      				not event(TaskAssignmentSummary_out);
      		
      		guarantee "The results of the optimization are packaged into the TaskAssignmentSummary and published, 
      			at which point this service returns to the idle state.":
      			wait_to_idle =>
      				state = IDLE;
      	**};
    end AssignmentTreeBranchBoundBase;

    
end AssignmentTreeBranchBoundBase_Pkg;