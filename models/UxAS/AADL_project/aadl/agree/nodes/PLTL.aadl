package PLTL
public
	annex agree{**

		node Historically(a : bool) returns (res : bool);
		let
		   res = H(a);
		tel;
	
		--Historically
		node H(a : bool) returns (res : bool);
		let
		   res = a and Z(res);
		tel;
		
		node Once(signal : bool) returns (res : bool);
		let
		   res = O(signal);
		tel;
		
		--Once
		node O(a : bool) returns (res : bool);
		let
		   res = a or Y(res);
		tel;
		
		node Yesterday(a : bool) returns (res : bool);
		let
		   res = Y(a);
		tel;
		
		--Yesterday
		node Y(a : bool) returns (res : bool);
		let
		   res = (false -> pre(a));
		tel;
		
		node Z(a : bool) returns (res : bool);
		let
		   res = (true -> pre(a));
		tel;
		
		node Since(a : bool, b : bool) returns (res : bool);
		let
		   res = S(a,b);
		tel;
		
		--Since
		node S(a : bool, b : bool) returns (res : bool);
		let
		   res = b or (a and Y(res));
		tel;
		
		node Trigger(a : bool, b : bool) returns (res : bool);
		let
		   res = T(a,b);
		tel;
		
		--Trigger
		node T(a : bool, b : bool) returns (res : bool);
		let
		   res = b and (a or Z(res));
		tel;
		
		--Until may never happen (this makes it weak), J does not ever have to occur
		node WeakUntil(i: bool, j: bool) returns (o: bool); 
		let
			o = Historically(i) or Once(j);
		tel; 
		
--		node first(a : bool) returns (res : bool);
--		let
--		   res = a and Z(H(not a));
--		tel;
--		
--		node properties(a : bool, b : bool) returns (p1 : bool,p2 : bool,p3 : bool,p4 : bool,p5 : bool,p6 : bool);
--		let
--		   p1 = not Y(a) = Z(not a);
--		   p2 = not Z(a) = Y(not a);
--		   p3 = not H(a) = O(not a);
--		   p4 = not O(a) = H(not a);
--		   p5 = not S(a,b) = T(not a, not b);
--		   p6 = not T(a,b) = S(not a, not b);
--		   
--		   --%PROPERTY p1;
--		   --%PROPERTY p2;
--		   --%PROPERTY p3;
--		   --%PROPERTY p4;
--		   --%PROPERTY p5;
--		   --%PROPERTY p6;
--		tel;

	**};
	
end PLTL;