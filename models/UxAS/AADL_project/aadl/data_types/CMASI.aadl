package CMASI
public
	with Common_Data;
	with Data_Model;
	with Base_Types;
	renames Common_Data::all;

data AbstractGeometry
end AbstractGeometry;

data AltitudeType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --Height above WGS84 ellipsoid, mean sea level
            "AGL",
            --Height above WGS84 ellipsoid, mean sea level
            "MSL");
end AltitudeType;

data implementation AltitudeType.i
end AltitudeType.i;

--Base class for geometry types
data implementation AbstractGeometry.i
end AbstractGeometry.i;

data KeyValuePair
end KeyValuePair;

--A container for key/value pairs. Keys and values can be any valid
--string.
data implementation KeyValuePair.i
    subcomponents
        --A key (name) for the property
        Key: data string.i;
        --A value for the property
        Value: data string.i;
end KeyValuePair.i;

data Location3D
end Location3D;

--Location is defined as a point in the world using the WGS84
--specification for latitude and longitude.
data implementation Location3D.i
    subcomponents
        --Latitude
        Latitude: data real64.i;
        --Longitude
        Longitude: data real64.i;
        --Altitude for this waypoint
        Altitude: data real32.i;
        --Altitude type for specified altitude
        AltitudeType: data AltitudeType.i;
end Location3D.i;

data PayloadAction extends VehicleAction
end PayloadAction;

--An action for controlling a payload item (abstract).
data implementation PayloadAction.i extends VehicleAction.i
    subcomponents
        --A unique id for this payload item.
        PayloadID: data int64.i;
end PayloadAction.i;

data PayloadConfiguration
end PayloadConfiguration;

--Base type for payloads
data implementation PayloadConfiguration.i
    subcomponents
        --The unique id for this payload item.
        PayloadID: data int64.i;
        --A string uniquely identifying the kind of payload item (primarily to
        --be used for debugging purposes).
        PayloadKind: data string.i;
        --Optional parameters associated with payload configuration
        Parameters: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end PayloadConfiguration.i;

data PayloadState
end PayloadState;

--Describes the current state of a payload item (abstract).
data implementation PayloadState.i
    subcomponents
        --The unique id for this payload item.
        PayloadID: data int64.i;
        --Optional parameters associated with payload state
        Parameters: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end PayloadState.i;

data VehicleAction
end VehicleAction;

--Base class for an action to be taken by a vehicle. This is usually
--used as an object inside of {@link Waypoint} to describe the action
--that a vehicle is to take upon reaching a waypoint. This is used by
--child types to perform something meaningful.<br/>
data implementation VehicleAction.i
    subcomponents
        --A list of tasks that are associated with this action. A length of
        --zero denotes no associated tasks. This field is for analysis purposes.
        --The automation service should associate a list of tasks with each
        --action to enable analysis of the allocation of tasks to vehicles.<br/>
        AssociatedTaskList: data int64.i {Data_Model::Data_Representation => Array;};
end VehicleAction.i;

data Task
end Task;

--The base class for all task requests passed to the automation
--service. Task requests are not assigned to a specific vehicle, but
--allow the automation service to determine the best vehicle to complete
--the task.
data implementation Task.i
    subcomponents
        --A unique identifier for this task.
        TaskID: data int64.i;
        --An optional text string for the task. This is not necesarily unique,
        --and is included for information only. TaskID should be used to
        --uniquely identify tasks.
        Label: data string.i;
        --A list of entity IDs that are eligible to accomplish this task. If
        --the list is empty, then it is assumed all entities are eligible.
        EligibleEntities: data int64.i {Data_Model::Data_Representation => Array;};
        --If a task is to be repeatedly done, this field indicates how often.
        --A value of zero means the task is complete on the first pass.
        RevisitRate: data real32.i;
        --An optional text string for automation service task parameters.
        Parameters: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
        --The priority value for this task. Priority is a relative value of
        --this task compared to other tasks in the scenario. This field should
        --be limited to the range[0..100], 100 being the highest level of
        --priority. The exact interpretation priority may vary depending on
        --algorithm implementation.
        Priority: data byte.i;
        --Indicates whether this task <i><b>must</b></i> be executed as part
        --of a mission plan.
        Required: data bool.i;
end Task.i;

data SearchTask extends Task
end SearchTask;

--Used to request a search task allocation from the automation
--service.
data implementation SearchTask.i extends Task.i
    subcomponents
        --The wavelength bands that should be used to complete the task.
        DesiredWavelengthBands: data WavelengthBand.i {Data_Model::Data_Representation => Array;};
        --Minimum time that a sensor must look at any given point in this
        --search task.
        DwellTime: data int64.i;
        --Average ground sample distance for locations in search area
        GroundSampleDistance: data real32.i;
end SearchTask.i;

data AbstractZone
end AbstractZone;

--Base Type for all zones (keep-in and keep-out zones)
data implementation AbstractZone.i
    subcomponents
        --A globally unique reference number for this zone
        ZoneID: data int64.i;
        --Lower altitude bound for the zone
        MinAltitude: data real32.i;
        --Altitude type for min altitude
        MinAltitudeType: data AltitudeType.i;
        --Maximum altitude for operations
        MaxAltitude: data real32.i;
        --Altitude type for max altitude
        MaxAltitudeType: data AltitudeType.i;
        --A list of aircraft IDs that this zone applies to. If the list is
        --empty, then it is assumed that the boundary applies to all aircraft.
        AffectedAircraft: data int64.i {Data_Model::Data_Representation => Array;};
        --Time at which this zone becomes active. Time datum is defined by the
        --application, but unless otherwise specified is milliseconds since 1
        --Jan 1970
        StartTime: data int64.i;
        --Time at which this zone becomes inactive. Time datum is defined by
        --the application, but unless otherwise specified is milliseconds since
        --1 Jan 1970
        EndTime: data int64.i;
        --Buffer to add/subtract around the border of the zone
        Padding: data real32.i;
        --Optional label for this zone
        Label: data string.i;
        --Geometry object describing the boundary. This boundary is
        --2-dimensional. The zone boundary is defined as an extrusion of this
        --boundary from MinAltitude to MaxAltitude.
        Boundary: data AbstractGeometry.i;
end AbstractZone.i;

data EntityConfiguration
end EntityConfiguration;

--Provides information regarding a base entitie's configuration items.
data implementation EntityConfiguration.i
    subcomponents
        --A unique id for this entity
        ID: data int64.i;
        --the team or "side" that an entity belongs to. This can be a name of
        --a country, a "friend" or "foe" designation, or a team name (e.g. "red
        --team").
        Affiliation: data string.i;
        --The type of this entity. The content of this field is dependent on
        --the session. The value of this field is not specifically defined, so
        --it is up to the simulation/session components to define a type system.
        --For a common entity definition, see MIL STD 2525 or use DIS
        --enumerations.
        EntityType: data string.i;
        --An optional text string for the vehicle. This is not necessarily
        --unique, and is included for information only. ID should be used to
        --uniquely identify entities.
        Label: data string.i;
        --The speed that is typically commanded for this entity
        NominalSpeed: data real32.i;
        --The altitude that is typically commanded for this entity
        NominalAltitude: data real32.i;
        --Altitude type for nominal altitude
        NominalAltitudeType: data AltitudeType.i;
        --A list of all payload configurations for this vehicle. Examples of
        --payloads include: gimbaled sensors, SAR radars (not yet supported),
        --air-launched UAVs (not yet supported), and weapons (not yet
        --supported).
        PayloadConfigurationList: data PayloadConfiguration.i {Data_Model::Data_Representation => Array;};
        --A list that maps keys to values for the inclusion of extra, custom
        --information about this entity
        Info: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end EntityConfiguration.i;

data FlightProfile
end FlightProfile;

--A set of parameter describing the operations of a vehicle. This can
--be used to set routing preferences for a particular vehicle. The
--"Name" field can be used to describe a given condition, such as
--"cruise" or "climb".
data implementation FlightProfile.i
    subcomponents
        --The unique name for this configuration
        Name: data string.i;
        --True Airspeed
        Airspeed: data real32.i;
        --The pitch angle of the aircraft in this flight condition(assuming
        --zero bank)
        PitchAngle: data real32.i;
        --Vertical speed (positive upwards) of the vehicle
        VerticalSpeed: data real32.i;
        --The maximum angle that this vehicle will bank
        MaxBankAngle: data real32.i;
        --The consumption rate of available energy, expressed in terms of the
        --percentage of maximum capacity used per second.
        EnergyRate: data real32.i;
end FlightProfile.i;

data AirVehicleConfiguration extends EntityConfiguration
end AirVehicleConfiguration;

--Provides information regarding a vehicle's configuration items.
data implementation AirVehicleConfiguration.i extends EntityConfiguration.i
    subcomponents
        --The minimum true airspeed that should be commanded for this aircraft
        MinimumSpeed: data real32.i;
        --The maximum true airspeed that should be commanded for this aircraft
        MaximumSpeed: data real32.i;
        --Describes the preferred operating mode for most planning purposes.
        --This can be a max range or endurance speed profile, or any other
        --operating point chosen by a user. This field may not be null.
        NominalFlightProfile: data FlightProfile.i;
        --A list of all flight configurations described for this vehicle. Each
        --flight configuration specifies a different mode of flight, for
        --instance: climb, cruise, dash, loiter. This list may be empty, and
        --does not necessarily contain the nominal flight configuration.
        AlternateFlightProfiles: data FlightProfile.i {Data_Model::Data_Representation => Array;};
        --A list of available loiter types for this aircraft
        AvailableLoiterTypes: data LoiterType.i {Data_Model::Data_Representation => Array;};
        --A list of available turning modes for this aircraft
        AvailableTurnTypes: data TurnType.i {Data_Model::Data_Representation => Array;};
        --Minimum MSL altitude that this aircraft is allowed to fly. This
        --value should be treated as a regulatory or safety-of-flight parameter
        --and therefore takes precedence over other requests.
        MinimumAltitude: data real32.i;
        --Altitude type for min altitude
        MinAltitudeType: data AltitudeType.i;
        --Maximum MSL altitude that this aircraft is allowed to fly. This
        --value should be treated as a regulatory or safety-of-flight parameter
        --and therefore takes precedence over other requests.
        MaximumAltitude: data real32.i;
        --Altitude type for max altitude
        MaxAltitudeType: data AltitudeType.i;
end AirVehicleConfiguration.i;

data EntityState
end EntityState;

--Reported state for an entity in the system
data implementation EntityState.i
    subcomponents
        --A unique ID for this entity. IDs should be greater than zero
        ID: data int64.i;
        --Velocity in the body x-direction (postive out nose)
        u: data real32.i;
        --Velocity in the body y-direction (positive out right wing)
        v: data real32.i;
        --Velocity in the body z-direction (positve downward)
        w: data real32.i;
        --Acceleration in the body x-direction (postive out nose)
        udot: data real32.i;
        --Acceleration in the body y-direction (positive out right wing)
        vdot: data real32.i;
        --Acceleration in the body z-direction (positve downward)
        wdot: data real32.i;
        --Angle between true North and the projection of the body x-axis in
        --the North-East plane.
        Heading: data real32.i;
        --Pitch of vehicle around body y-axis (positive upwards)
        Pitch: data real32.i;
        --Roll angle of the vehicle around body x-axis (positive right wing
        --down)
        Roll: data real32.i;
        --roll-rate of vehicle (angular velocity around body x-axis). Positive
        --right-wing down.
        p: data real32.i;
        --pitch rate of the vehicle (angular velocity around body y-axis).
        --Positive nose-up.
        q: data real32.i;
        --yaw rate of the vehicle (angular velocity around body z-axis).
        --Positive nose right.
        r: data real32.i;
        --Course/Groundtrack angle of the entity referenced to true North
        Course: data real32.i;
        --Current entity ground speed
        Groundspeed: data real32.i;
        --The perceived entity location
        Location: data Location3D.i;
        --The available energy remaining, expressed in terms of the percentage
        --of maximum capacity
        EnergyAvailable: data real32.i;
        --The consumption rate of available energy, expressed in terms of the
        --percentage of maximum capacity used per second.
        ActualEnergyRate: data real32.i;
        --A list of states for any onboard payloads
        PayloadStateList: data PayloadState.i {Data_Model::Data_Representation => Array;};
        --The ID of the current waypoint. Only valid if the vehicle is in
        --waypoint following mode.
        CurrentWaypoint: data int64.i;
        --Current command (VehicleActionCommand or MissionCommand) being
        --executed. A value of zero denotes no command being executed, or that a
        --command without an set identifier (CommandID) is being executed.
        CurrentCommand: data int64.i;
        --The current mode for this vehicle.
        FIXMEMode: data NavigationMode.i;
        --Tasks that this entity is currently executing. An empty list
        --indicates no associated tasks. The task number should coincide with
        --the task number in the task request. For instance, if a waypoint is
        --associated with a search task, then the task number associated with
        --that search should be included in this list.
        AssociatedTasks: data int64.i {Data_Model::Data_Representation => Array;};
        --time stamp of this data. Time datum is defined by the application,
        --but unless otherwise specified is milliseconds since 1 Jan 1970
        Time: data int64.i;
        --A list that maps keys to values for the inclusion of extra, custom
        --information about this entity
        Info: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end EntityState.i;

data AirVehicleState extends EntityState
end AirVehicleState;

--Provides basic information regarding the vehicle state with regard
--to its location and orientation in the world, and current velocity in
--body axis. <br/> Provides basic state information regarding entity
--position, orientation, velocity, and acceleration. The entity body
--right-hand coordinate system is used, where X is out the nose, Y is
--out the right side, and Z is downward. The order of rotation from
--inertial to body coordinates is yaw-pitch-roll. <br/> The direction
--cosine matrix (DCM) for conversion from body to inertial coordinates
--is:<br/><br/> [cTheta*cPsi, cTheta*sPsi, -sTheta]<br/> [sPhi*sTheta
--*cPsi-cPhi*sPsi, sPhi*sTheta*sPsi+cPhi*cPsi, sPhi*cTheta]<br/>
--[cPhi*sTheta*cPsi+sPhi*sPsi, cPhi*sTheta*sPsi-sPhi*cPsi,
--cPhi*cTheta]<br/><br/> where, c denotes cosine and s denotes sine.
--<br/><br/> To convert from body to inertial velocities, use,<br/>
--[North Vel, East Vel, Down Vel]' = DCM' * [Vx, Vy, Vz]' where [Vx, Vy,
--Vz] is the body vel or accel.
data implementation AirVehicleState.i extends EntityState.i
    subcomponents
        --vehicle true airspeed
        Airspeed: data real32.i;
        --Vertical speed (positive upwards) of the vehicle in the inertial
        --frame (rate of change of altitude)
        VerticalSpeed: data real32.i;
        --Wind speed as detected or computed by the vehicle
        WindSpeed: data real32.i;
        --Wind source direction (true) as detected or computed by the vehicle
        WindDirection: data real32.i;
end AirVehicleState.i;

data Wedge
end Wedge;

--Defines an angular range for use in setting constraints or desired
--approaches to tasks. In most cases, wedges are defined in the inertial
--sense, where azimuth is the angle between North and the center of the
--wedge, elevation is the angle between the horizon and the center of
--the wedge. In some instances, other coordinate systems are defined,
--such as angles relative to a line.
data implementation Wedge.i
    subcomponents
        --Azimuthal centerline of the wedge.
        AzimuthCenterline: data real32.i;
        --Vertical centerline of the wedge.
        VerticalCenterline: data real32.i;
        --Azimuthal angular extent of the wedge. The extent is centered around
        --the centerline. A value of zero denotes that this wedge is defined as
        --a single angle.
        AzimuthExtent: data real32.i;
        --Vertical angular extent of the wedge. The extent is centered around
        --the centerline. A value of zero denotes that this wedge is defined as
        --a single angle.
        VerticalExtent: data real32.i;
end Wedge.i;

data AreaSearchTask extends SearchTask
end AreaSearchTask;

--Area search task
data implementation AreaSearchTask.i extends SearchTask.i
    subcomponents
        --Area to search
        SearchArea: data AbstractGeometry.i;
        --A list of acceptable look-angles for this task. Each wedge is
        --defined relative to true North. To be a valid look angle, a sensor
        --must be looking from a direction within the bounds of the wedge.
        ViewAngleList: data Wedge.i {Data_Model::Data_Representation => Array;};
end AreaSearchTask.i;

data CameraAction extends PayloadAction
end CameraAction;

--An action for controlling a camera that is mounted on a gimbal.
data implementation CameraAction.i extends PayloadAction.i
    subcomponents
        --The commanded horizontal (azimuth) field of view.
        HorizontalFieldOfView: data real32.i;
        --Associated payload actions that should be performed simultaneously
        --with the change in field of view. A frequent use case would be a
        --gimbal pointing action. If payload ID is zero, then the gimbal on
        --which the camera is mounted is selected. Note that this has the side-
        --effect of steering all other payloads associated to that gimbal.
        AssociatedActions: data PayloadAction.i {Data_Model::Data_Representation => Array;};
end CameraAction.i;

data CameraConfiguration extends PayloadConfiguration
end CameraConfiguration;

--Description of capabilities of a camera (EO, LWIR, SWIR, MWIR,
--etc.). If a camera has multiple bands, then a CameraConfiguration for
--each camera mode should be included in the
--PayloadConfigurationList.<br/> <i>Note on Aspect ratio:</i> Aspect
--ratio is computed by taking the ratio of
--VideoStreamHorizontalResolution and VideoStreamVerticalResolution. It
--is assumed that the camera has a constant aspect ratio through all
--fields-of-view and that the field-of-view aspect ratio is the same as
--the video stream aspect ratio.
data implementation CameraConfiguration.i extends PayloadConfiguration.i
    subcomponents
        --The supported wavelength band of this camera
        SupportedWavelengthBand: data WavelengthBand.i;
        --The manner in which field of views are commanded: Continuous (any
        --FOV between MinHorizontalFieldOfView and MaxHorizontalFieldOfView can
        --be commanded), or Discrete (the only supported FOVs are listed in
        --DiscreteHorizontalFieldOfViewList).
        FieldOfViewMode: data FOVOperationMode.i;
        --The minimum horizontal field of view of the sensor. Only used if
        --FieldOfViewMode is Continuous.
        MinHorizontalFieldOfView: data real32.i;
        --The maximum horizontal field of view of the sensor. Only used if
        --FieldOfViewMode is Continuous.
        MaxHorizontalFieldOfView: data real32.i;
        --The horizontal field of views supported by the sensor. Only used if
        --FieldOfViewMode is Discrete.
        DiscreteHorizontalFieldOfViewList: data real32.i {Data_Model::Data_Representation => Array;};
        --The number of horizontal pixels in the output live-motion video
        --stream.
        VideoStreamHorizontalResolution: data uint32.i;
        --The number of vertical pixels in the output live-motion video
        --stream.
        VideoStreamVerticalResolution: data uint32.i;
end CameraConfiguration.i;

data GimballedPayloadState extends PayloadState
end GimballedPayloadState;

--Describes the current state of a camera.
data implementation GimballedPayloadState.i extends PayloadState.i
    subcomponents
        --Current pointing mode of the gimbal to which this payload is
        --attached
        PointingMode: data GimbalPointingMode.i;
        --Current azimuth angle of the gimbal boresight (positive from vehicle
        --x-axis).
        Azimuth: data real32.i;
        --Current elevation angle of the gimbal boresight (positive from
        --vehicle x-y plane).
        Elevation: data real32.i;
        --Current rotation angle of the gimbal boresight (0 degrees aligned
        --with aircraft normal, positive clockwise).
        Rotation: data real32.i;
end GimballedPayloadState.i;

data CameraState extends GimballedPayloadState
end CameraState;

--Describes the current state of a camera.
data implementation CameraState.i extends GimballedPayloadState.i
    subcomponents
        --The current horizontal field of view (in sensor axis).
        HorizontalFieldOfView: data real32.i;
        --The current vertical field of view (in sensor axis).
        VerticalFieldOfView: data real32.i;
        --The current sensor footprint of the camera represented as a polygon
        --with n-vertices. If this field contains zero items then the footprint
        --is unavailable or was not calculated.
        Footprint: data Location3D.i {Data_Model::Data_Representation => Array;};
        --the current location according to the intersection of a ray along
        --the center axis of the current camera field of view with the ground.
        --If this field is null, then the location was not computed.
        Centerpoint: data Location3D.i;
end CameraState.i;

data Circle extends AbstractGeometry
end Circle;

--Defines a circular shape based on a center point and radius
data implementation Circle.i extends AbstractGeometry.i
    subcomponents
        --Center point of the circle
        CenterPoint: data Location3D.i;
        --Radius of the circle
        Radius: data real32.i;
end Circle.i;

data GimbalAngleAction extends PayloadAction
end GimbalAngleAction;

--An action for controlling the movement of a gimbal. Individual
--sensors on the gimbal are controlled via the {@link CameraAction}
--message.<br/> Azimuth is defined as the angle between the long axis of
--the aircraft and the sensor boresight, positive clockwise.<br/>
--Elevation is defined as the angle between the aircraft long-lat plane
--and the sensor boresight, positive upwards.<br/> Rotation is defined
--as rotation from the aircraft normal (Up), positive clockwise.<br/>
data implementation GimbalAngleAction.i extends PayloadAction.i
    subcomponents
        --The commanded azimuth angle (0 degrees out of nose, positive
        --clockwise).
        Azimuth: data real32.i;
        --The commanded elevation angle (0 degrees horizontal, positive
        --upwards).
        Elevation: data real32.i;
        --The commanded rotation angle (0 degrees aligned with aircraft
        --normal, positive clockwise).
        Rotation: data real32.i;
end GimbalAngleAction.i;

data GimbalConfiguration extends PayloadConfiguration
end GimbalConfiguration;

--Description of a gimbal's capabilities. A gimbal is defined as the
--mount of a sensor or set of sensors that may or may not have freedom
--of motion (for instance, the fixed mounting of a camera would still be
--considered a gimbal payload that must be defined).<br/> Azimuth is
--defined as the angle between the long axis of the aircraft and the
--sensor boresight, positive clockwise.<br/> Elevation is defined as the
--angle between the aircraft long-lat plane and the sensor boresight,
--positive upwards.<br/> Rotation is defined as rotation from the
--aircraft normal (Up), positive clockwise.<br/>
data implementation GimbalConfiguration.i extends PayloadConfiguration.i
    subcomponents
        --The pointing modes supported by the gimbal
        SupportedPointingModes: data GimbalPointingMode.i {Data_Model::Data_Representation => Array;};
        --Minimum azimuth that this sensor can slew in body axis (0 degrees
        --out of nose, positive clockwise). If this is a fixed-azimuth sensor,
        --then this should be set to the fixed azimuth value.
        MinAzimuth: data real32.i;
        --Maximum azimuth that this sensor can slew in body axis (0 degrees
        --out of nose, positive clockwise). If this is a fixed-azimuth sensor,
        --then this should be set to the fixed azimuth value.
        MaxAzimuth: data real32.i;
        --Determines whether there are any limits on the azimuth of the
        --gimbal. If this is set to false, then MinAzimuth and MaxAzimuth are
        --not used, and the gimbal is capable of continuously spinning in a 360
        --degree circle without hitting any stops.
        IsAzimuthClamped: data bool.i;
        --Minimum elevation that this sensor can slew in body axis (0 degrees
        --horizontal, positive upwards). If this is a fixed-elevation sensor,
        --then this should be set to the fixed elevation value.
        MinElevation: data real32.i;
        --Maximum elevation that this sensor can slew in body axis (0 degrees
        --horizontal, positive upwards). If this is a fixed-elevation sensor,
        --then this should be set to the fixed elevation value.
        MaxElevation: data real32.i;
        --Determines whether there are any limits on the elevation of the
        --gimbal. If this is set to false, then MinElevation and MaxElevation
        --are not used, and the gimbal is capable of continuously spinning in a
        --360 degree circle without hitting any stops.
        IsElevationClamped: data bool.i;
        --Minimum rotation that this sensor can slew in body axis (0 degrees
        --aligned with aircraft normal, positive clockwise). If this is a fixed-
        --rotation sensor, then this should be set to the fixed rotation value.
        MinRotation: data real32.i;
        --Maximum rotation that this sensor can slew in body axis (0 degrees
        --aligned with aircraft normal, positive clockwise). If this is a fixed-
        --rotation sensor, then this should be set to the fixed rotation value.
        MaxRotation: data real32.i;
        --Determines whether there are any limits on the rotation of the
        --gimbal. If this is set to false, then MinRotation and MaxRotation are
        --not used, and the gimbal is capable of continuously rotating in a 360
        --degree circle without hitting any stops.
        IsRotationClamped: data bool.i;
        --Rate of maximum horizontal slew for this gimbal.
        MaxAzimuthSlewRate: data real32.i;
        --Rate of maximum vertical slew for this gimbal.
        MaxElevationSlewRate: data real32.i;
        --Rate of maximum rotation for this gimbal.
        MaxRotationRate: data real32.i;
        --Lists the PayloadID of each sensor physically located within the
        --gimbal and that shares the same gimbal angles. It is assumed that all
        --sensors are boresighted.
        ContainedPayloadList: data int64.i {Data_Model::Data_Representation => Array;};
end GimbalConfiguration.i;

data GimbalScanAction extends PayloadAction
end GimbalScanAction;

--Parameters for controlling the movement of a sensor in a continuous
--motion. This can be used to start a back-and-forth or rotational scan
--over time. The sensor will sweep in a box pattern from the corner
--defined by: (StartAzimuth, StartElevation) to (StartAzimuth,
--EndElevation) to (EndAzimuth, EndElevation) to (EndAzimuth,
--StartElevation) and back to the origin.
data implementation GimbalScanAction.i extends PayloadAction.i
    subcomponents
        --sets the time-to-scan in the azimuthal direction. This is the time
        --to complete one sweep through the the length of EndAzimuth -
        --StartAzimuth.
        AzimuthSlewRate: data real32.i;
        --sets the time-to-scan in the elevation direction. This is the time
        --to complete one sweep through the the length of EndElevation -
        --StartElevation.
        ElevationSlewRate: data real32.i;
        --The starting azimuth for the sensor scan (boresight angle right of
        --aircraft long axis)
        StartAzimuth: data real32.i;
        --The ending azimuth for the sensor scan (boresight angle right of
        --aircraft long axis)
        EndAzimuth: data real32.i;
        --The starting elevation for the sensor scan (boresight angle positive
        --from aircraft x-y plane)
        StartElevation: data real32.i;
        --The ending elevation for the sensor scan (boresight angle positive
        --from aircraft x-y plane)
        EndElevation: data real32.i;
        --Number of sensor sweeps to perform. A zero value denotes indefinite
        --number of sweeps.
        Cycles: data uint32.i;
end GimbalScanAction.i;

data GimbalStareAction extends PayloadAction
end GimbalStareAction;

--An action that commands a gimbal to make necessary rotations to
--allow mounted sensors to stare at the given location.Individual
--sensors on the gimbal are controlled via the {@link CameraAction}
--message.<br/>
data implementation GimbalStareAction.i extends PayloadAction.i
    subcomponents
        --The commanded stare point.
        Starepoint: data Location3D.i;
        --Duration for the stare operation. Zero denotes an indefinate stare
        --time
        Duration: data int64.i;
end GimbalStareAction.i;

data GimbalState extends PayloadState
end GimbalState;

--Describes the current state of a gimbal and the sensors mounted
--within it.
data implementation GimbalState.i extends PayloadState.i
    subcomponents
        --Current pointing mode of the gimbal
        PointingMode: data GimbalPointingMode.i;
        --Current azimuth angle of the gimbal boresight (positive from vehicle
        --x-axis).
        Azimuth: data real32.i;
        --Current elevation angle of the gimbal boresight (positive from
        --vehicle x-y plane).
        Elevation: data real32.i;
        --Current rotation angle of the gimbal boresight (0 degrees aligned
        --with aircraft normal, positive clockwise).
        Rotation: data real32.i;
end GimbalState.i;

data GoToWaypointAction extends NavigationAction
end GoToWaypointAction;

--Commands an aircraft to start flying towards a given waypoint in its
--waypoint list. This action depends on an aircraft already having the
--given waypoint in its current list. A {@link MissionCommand} should be
--sent if new waypoints are required. The aircraft will remain in
--waypoint mode and will continue to fly its linked-list waypoint route
--until otherwise commanded.
data implementation GoToWaypointAction.i extends NavigationAction.i
    subcomponents
        --Waypoint number to which the aircraft should fly.
        WaypointNumber: data int64.i;
end GoToWaypointAction.i;

data KeepInZone extends AbstractZone
end KeepInZone;

--Describes the outer boundary of operations for the entire UAV team
--or a subset of the vehicle team.
data implementation KeepInZone.i extends AbstractZone.i
end KeepInZone.i;

data KeepOutZone extends AbstractZone
end KeepOutZone;

--Defines a keep-out zone. This describes a volume where vehicles are
--not allowed to fly. For standard zones, this Struct defines lateral
--boundaries.
data implementation KeepOutZone.i extends AbstractZone.i
    subcomponents
        --The type of zone <br/> Physical (physical boundary such as terrain
        --or buildings) <br/> Regulatory (fire control, flight corridor) <br/>
        --Acoustic Defines an area for acoustical avoidance <br/> Threat Defines
        --an area where a threat is present.
        ZoneType: data ZoneAvoidanceType.i;
end KeepOutZone.i;

data LineSearchTask extends SearchTask
end LineSearchTask;

--Defines a line search task. A line search is a list of points that
--forms a polyline. The ViewAngleList determines from which direction
--the line may be viewed. View angles are specified using the {@link
--Wedge} type. If the UseInertialViewAngles option is true, then wedges
--are defined in terms of North-East coordinates, otherwise wedges are
--defined relative to the line segment currently being viewed (a vector
--from point i through point i+1). To be a valid look angle, the line
--segment must be viewed from an angle within the bounds of the wedge.
data implementation LineSearchTask.i extends SearchTask.i
    subcomponents
        --Line to search
        PointList: data Location3D.i {Data_Model::Data_Representation => Array;};
        --Defines a list of acceptable look-angles for this task. See the
        --documentation above for details.
        ViewAngleList: data Wedge.i {Data_Model::Data_Representation => Array;};
        --If true, the ViewAngleList specifies inertial (North-East) angles.
        --See documentation above.
        UseInertialViewAngles: data bool.i;
end LineSearchTask.i;

data NavigationAction extends VehicleAction
end NavigationAction;

--Base action class for all navigation actions that the vehicle may
--take
data implementation NavigationAction.i extends VehicleAction.i
end NavigationAction.i;

data LoiterAction extends NavigationAction
end LoiterAction;

--Used to command a vehicle to go into a vehicle-specific hold
--pattern.
data implementation LoiterAction.i extends NavigationAction.i
    subcomponents
        --The loiter shape that the vehicle should fly
        LoiterType: data LoiterType.i;
        --The radius for the loiter. May be used for any curvature parameter
        --of the vehicle specific hold pattern.
        Radius: data real32.i;
        --Direction of the major axis of the vehicle specific hold pattern.
        --For Racetracks and Figure-Eights, this is the direction of the long
        --axis. Hovering loiters, this is direction the aircraft should face in
        --the loiter.
        Axis: data real32.i;
        --Used in racetrack and figure-eight loiters. For figure-eight
        --loiters, this is the length between the focii of the turn circles. For
        --racetracks, this is the length of the straight-away. Both types have a
        --total length of Length + 2 * Radius. For figure-eight loiters, if
        --Length is less than 2 * radius, then this field is ignored.
        Length: data real32.i;
        --Direction of travel.
        Direction: data LoiterDirection.i;
        --The time to loiter at this point before continuing. A negative time
        --value denotes perpetual orbit.
        Duration: data int64.i;
        --Commanded True Airspeed
        Airspeed: data real32.i;
        --The geometric center point of the loiter.
        Location: data Location3D.i;
end LoiterAction.i;

data LoiterTask extends Task
end LoiterTask; 

--Used to define a loiter request from the automation service.
data implementation LoiterTask.i extends Task.i
    subcomponents
        --The desired loiter action to take
        DesiredAction: data LoiterAction.i;
end LoiterTask.i;

data Waypoint extends Location3D
end Waypoint;

--A simple waypoint class for vehicle routing
data implementation Waypoint.i extends Location3D.i
    subcomponents
        --A unique waypoint number
        Number: data int64.i;
        --The index of the next waypoint in the list. Consecutively numbered
        --waypoints are <b>not</b> considered linked, the link must be
        --explicitly stated in this field.
        NextWaypoint: data int64.i;
        --Commanded speed for this waypoint. See SpeedType for defintion of
        --this field.
        Speed: data real32.i;
        --Type of commanded speed
        SpeedType: data SpeedType.i;
        --The commanded climb rate. Positive values upwards. For surface
        --(ground and sea) entities, this value is ignored.
        ClimbRate: data real32.i;
        --The type of turn to execute
        TurnType: data TurnType.i;
        --A list of actions to perform at this waypoint
        VehicleActionList: data VehicleAction.i {Data_Model::Data_Representation => Array;};
        --A waypoint for contingency (e.g. lost-comm, alternate mission)
        --operations. A value of zero denotes that no contingency point is
        --specified.
        ContingencyWaypointA: data int64.i;
        --A waypoint for contingency (e.g. lost-comm, alternate mission)
        --operations. A value of zero denotes that no contingency point is
        --specified.
        ContingencyWaypointB: data int64.i;
        --A list of tasks that are associated with this waypoint. A length of
        --zero denotes no associated tasks. This field is for analysis purposes.
        --The automation service should associate a list of tasks with each
        --waypoint to enable analysis of the allocation of tasks to vehicles.
        AssociatedTasks: data int64.i {Data_Model::Data_Representation => Array;};
end Waypoint.i;

data MissionCommand extends VehicleActionCommand
end MissionCommand;

--A mission to be performed by a vehicle. This sends a new list of
--waypoints to an aircraft and commands the aircraft to start flying the
--mission starting at the specified "FirstWaypoint". A Mission command
--is made up of a linked list of waypoints. However, the waypoint list
--may contain other waypoints that are not linked to the main route path
--that begins with "FirstWaypoint".<br/> <i>Note on end-of-mission
--behavior: </i> The last waypoint in the linked route list should
--include some terminal behavior. For instance, the last waypoint should
--be directed with itself as the "Next Waypoint" or there should be an
--indefinite loiter assigned in the last waypoint's
--"VehicleActionList".<br/> VehicleActionLists are performed immediately
--when MissionCommand is received, e.g. camera pointed toward first
--waypoint.
data implementation MissionCommand.i extends VehicleActionCommand.i
    subcomponents
        --The list of waypoints associated with this mission task. Waypoints
        --are linked, but the waypoint list may contain waypoints that are not
        --necessarily linked. Multiple linked routes may be sent in a single
        --waypoint list. Waypoints are not necessarily ordered in the list.
        WaypointList: data Waypoint.i {Data_Model::Data_Representation => Array;};
        --ID of the first waypoint to follow.
        FirstWaypoint: data int64.i;
end MissionCommand.i;

data MustFlyTask extends Task
end MustFlyTask;

--Used to request a must-fly task with optional action list.
data implementation MustFlyTask.i extends Task.i
    subcomponents
        --point that must vehicle must fly through
        Position: data Location3D.i;
        --Denotes whether altitude should be used in this MustFlyTask. If
        --false, the aircraft should maintain altitude according to previous
        --commands.
        UseAltitude: data bool.i;
end MustFlyTask.i;

data OperatorSignal
end OperatorSignal;

--Used to send operator interaction information to automation system
--during task execution
data implementation OperatorSignal.i
    subcomponents
        --Content of signal (e.g. button clicked)
        Signals: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end OperatorSignal.i;

data OperatingRegion
end OperatingRegion;

--Collection of extrusions/zones that define operating region
data implementation OperatingRegion.i
    subcomponents
        --Operating region ID
        ID: data int64.i;
        --Abstract Zone IDs in which the entity must remain during operation
        KeepInAreas: data int64.i {Data_Model::Data_Representation => Array;};
        --Keep Out Zone IDs that an entity must remain out of during operation
        KeepOutAreas: data int64.i {Data_Model::Data_Representation => Array;};
end OperatingRegion.i;

data AutomationRequest
end AutomationRequest;

--This is the primary message for requesting action from the
--automation service. The automation service is to use the list of
--vehicles, tasks (with associated task relationships), keep-out zones,
--and keep-in zones to produce {@link MissionCommands} for the vehicles
--requested. The automation service should only produce commands for the
--vehicles requested, but is not required to produce plans for all
--vehicles. If multiple {@link AutomationRequest} messages are sent to
--the automation service, only the last message will be considered, i.e.
--a new plan request supercedes all previous ones.
data implementation AutomationRequest.i
    subcomponents
        --List of entities to consider when planning.
        EntityList: data int64.i {Data_Model::Data_Representation => Array;};
        --list of task IDs (defined by {@link Task} messages) to be planned
        --for by the automation service
        TaskList: data int64.i {Data_Model::Data_Representation => Array;};
        
        -- ADDED: BDR (20170808)
		-- Size of the TaskList (not necessary if AGREE can get array size)		
        TaskListSize : data int64.i;
        
        --string containing the relationship between requested tasks. If
        --empty, all tasks are to be completed in any order. The format of the
        --string is specific to the automation service. This relationship string
        --is the mechanism for incorporating task precedence, priority, timing,
        --etc.
        TaskRelationships: data string.i;
        --Operating region ID to be considered during planning
        OperatingRegion: data int64.i;
        --Denotes that that the planner should restart any tasks that have
        --been performed or are currently being performed. This is useful in
        --situations when a task request contains tasks that have been requested
        --previously, and the operator wishes to restart the mission plans from
        --the beginning.
        RedoAllTasks: data bool.i;
end AutomationRequest.i;

data PointSearchTask extends SearchTask
end PointSearchTask;

--Point search task
data implementation PointSearchTask.i extends SearchTask.i
    subcomponents
        --Point to search
        SearchLocation: data Location3D.i;
        --Minimum distance that an aircraft must maintain from the point of
        --interest.
        StandoffDistance: data real32.i;
        --A list of acceptable look-angles for this task. Each wedge is
        --defined relative to true North. To be a valid look angle, a sensor
        --must be looking from a direction within the bounds of the wedge.
        ViewAngleList: data Wedge.i {Data_Model::Data_Representation => Array;};
end PointSearchTask.i;

data Polygon extends AbstractGeometry
end Polygon;

--Describes a polygon defined by geographic locations. Altitude value
--of points is ignored.
data implementation Polygon.i extends AbstractGeometry.i
    subcomponents
        --Boundary points for the polygon
        BoundaryPoints: data Location3D.i {Data_Model::Data_Representation => Array;};
end Polygon.i;

data Rectangle extends AbstractGeometry
end Rectangle;

--Defines a rectangular shape based on a corner point, width, height,
--and rotation
data implementation Rectangle.i extends AbstractGeometry.i
    subcomponents
        --Center point of the rectangle. Altitude value is ignored
        CenterPoint: data Location3D.i;
        --Width of the rectangle
        Width: data real32.i;
        --Height of the rectangle
        Height: data real32.i;
        --Rotation of the rectangle around the center point (positive from
        --north axis towards east)
        Rotation: data real32.i;
end Rectangle.i;

data RemoveTasks
end RemoveTasks;

--Sent to denote that the target id numbers in the list are obsolete
--and will not be requested again. This can occur when the user has
--replaced an old task with a new one, or has deleted a task
--permanently. This is an optional message that automation services can
--ignore, depending on how they manage tasks.
data implementation RemoveTasks.i
    subcomponents
        --Sent to denote that the target id numbers in the list are obsolete
        --and will not be requested again. This can occur when the user has
        --replaced an old task with a new one, or has deleted a task
        --permanently. This is an optional message that automation services can
        --ignore, depending on how they manage tasks.
        TaskList: data int64.i {Data_Model::Data_Representation => Array;};
end RemoveTasks.i;

data ServiceStatus
end ServiceStatus;

--Provides information regarding automation service compuation percent
--complete. The automation service should send this when the computation
--of a mission plan may take more than a few seconds, or when an error
--occurs (such as the inability to create one or more mission commands
--given the task set)
data implementation ServiceStatus.i
    subcomponents
        --The estimated percentage completed for an automation process.
        PercentComplete: data real32.i;
        --Status from the automation service to the simulation regarding
        --errors or conditions.
        Info: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
        --Describes the type of message conveyed. <br/> Information. Used to
        --note normal progress updates <br/> Warning. Notes non-fatal problem(s)
        --in data or processing <br/> Error. Notes fatal problem(s) <br/>
        StatusType: data ServiceStatusType.i;
end ServiceStatus.i;

data SessionStatus
end SessionStatus;

--Provides information regarding the state of a simulation or real-
--world. <br/>
data implementation SessionStatus.i
    subcomponents
        --The current state of the session
        State: data SimulationStatusType.i;
        --The simulation or scenario start time. This is absolute time in
        --milliseconds since epoch (1 Jan 1970 00:00 GMT). If this field is
        --zero, then no start time is specfied and each sim component is to use
        --the first receipt of this Struct with a SimStatus of "Running" as the
        --start time.
        StartTime: data int64.i;
        --The current time in scenario time . This is the internal time for
        --the simulation, not the absolute time since epoch, as in "StartTime".
        --The internal simualation time is based on the start time and the real-
        --time muiltiple, which can change throughout the simulation.
        ScenarioTime: data int64.i;
        --The ratio of simulation time to real time. Values greater than 1.0
        --denote faster than real-time. Values less than 0.0 have no meaning.
        RealTimeMultiple: data real32.i;
        --A field to store command-line style parameters used to initialize or
        --modify an execution.
        Parameters: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end SessionStatus.i;

data VehicleActionCommand
end VehicleActionCommand;

--A message that specifies actions that should be performed by the
--specified aircraft. Actions can be navigational modes or payload
--actions.
data implementation VehicleActionCommand.i
    subcomponents
        --A unique id for this command. automation services should issue new
        --ids with every new command
        CommandID: data int64.i;
        --The id of the vehicle for this command.
        VehicleID: data int64.i;
        --a set of actions to be performed immediately by the vehicle.
        VehicleActionList: data VehicleAction.i {Data_Model::Data_Representation => Array;};
        --Denotes the current execution status of this command.
        Status: data CommandStatusType.i;
end VehicleActionCommand.i;

data VideoStreamAction extends VehicleAction
end VideoStreamAction;

--An action for controlling which sensor is being transmitted on a
--video stream.
data implementation VideoStreamAction.i extends VehicleAction.i
    subcomponents
        --A unique id for the video stream.
        VideoStreamID: data int32.i;
        --The PayloadID of the sensor which should be activated on this video
        --stream.
        ActiveSensor: data int32.i;
end VideoStreamAction.i;

data VideoStreamConfiguration extends PayloadConfiguration
end VideoStreamConfiguration;

--Description of a video stream transmitted by the aircraft
--(specifically, what sensors are available to be transmitted via the
--stream).
data implementation VideoStreamConfiguration.i extends PayloadConfiguration.i
    subcomponents
        --List the PayloadID of each sensor that is multiplexed into this
        --stream. The {@link VideoStreamAction} message selects which of these
        --sensors is currently active on the stream.
        AvailableSensorList: data int64.i {Data_Model::Data_Representation => Array;};
end VideoStreamConfiguration.i;

data VideoStreamState extends PayloadState
end VideoStreamState;

--Describes the current state of a video stream.
data implementation VideoStreamState.i extends PayloadState.i
    subcomponents
        --The PayloadID of the sensor which is active on this video stream..
        ActiveSensor: data int64.i;
end VideoStreamState.i;

data AutomationResponse
end AutomationResponse;

--Encapsulates data from an automation service to a client. The
--automation service may respond with MissionCommands,
--VehicleActionCommands, or no commands at all. This type is meant to
--serve as a single container for commands that are a response to {@link
--AutomationRequest}
data implementation AutomationResponse.i
    subcomponents
        --A list of MissionCommands issued by the automation service
        MissionCommandList: data MissionCommand.i {Data_Model::Data_Representation => Array;};
        --A list of VehicleActionCommands issued by the automation service
        VehicleCommandList: data VehicleActionCommand.i {Data_Model::Data_Representation => Array;};
        --Status from the automation service to the simulation regarding
        --errors or conditions.
        Info: data KeyValuePair.i {Data_Model::Data_Representation => Array;};
end AutomationResponse.i;

data RemoveZones
end RemoveZones;

--Denotes a list of zones that should be removed permanently from the
--scenario.
data implementation RemoveZones.i
    subcomponents
        --List of zones to remove
        ZoneList: data int64.i {Data_Model::Data_Representation => Array;};
end RemoveZones.i;

data RemoveEntities
end RemoveEntities;

--Denotes a list of entities that should be removed permanently from
--the scenario.
data implementation RemoveEntities.i
    subcomponents
        --List of entities to remove
        EntityList: data int64.i {Data_Model::Data_Representation => Array;};
end RemoveEntities.i;

data FlightDirectorAction extends NavigationAction
end FlightDirectorAction;

--A command to "direct" the aircraft on a particular vector. This can
--be passed directly to the autopilot, or be directed to the operator as
--the current command to follow.
data implementation FlightDirectorAction.i extends NavigationAction.i
    subcomponents
        --Speed to fly
        Speed: data real32.i;
        --type of speed to fly
        SpeedType: data SpeedType.i;
        --True heading to fly
        Heading: data real32.i;
        --Altitude to maintain.
        Altitude: data real32.i;
        --Altitude type for specified altitude
        AltitudeType: data AltitudeType.i;
        --target climb/descent rate for changing altitude
        ClimbRate: data real32.i;
end FlightDirectorAction.i;

data WeatherReport
end WeatherReport;

--Reports current weather conditions. A weather report can cover a
--given geographic area or the entire scenario. Multiple reports can be
--issued during a scenario to indicate varying weather conditions over
--time or space. Mission planners can use weather reports to plan or can
--read current wind conditions as reported by aircraft as part of {@link
--AirVehicleState}.
data implementation WeatherReport.i
    subcomponents
        --The area for which this report pertains. If this is null, then the
        --report pertains to the entire area.
        Area: data AbstractZone.i;
        --Windspeed value for this area
        WindSpeed: data real32.i;
        --Wind direction. Direction is the true heading from which the wind is
        --blowing.
        WindDirection: data real32.i;
        --Visibility, according to the <a
        --href="http://en.wikipedia.org/wiki/Visibility">ICAO definition</a>.
        Visibility: data real32.i;
        --Height of the bottom of a cloud layer, in MSL altitude. If there is
        --more than one cloud layer, create WeatherReports for each zone that
        --contains a cloud layer. A value of "0" denotes free-of-clouds
        CloudCeiling: data real32.i;
        --Amount of cloud coverage for the given cloud layer. Values should be
        --0..1, 0 denoting free-of-clouds, and 1 denoting overcast.
        CloudCoverage: data real32.i;
end WeatherReport.i;

data FollowPathCommand extends VehicleActionCommand
end FollowPathCommand;

--A command to follow a set of ground waypoints. This is analogous to
--a {@link MissionCommand} for aircraft.
data implementation FollowPathCommand.i extends VehicleActionCommand.i
    subcomponents
        --The first waypoint to follow. This should correspond to the number
        --of a waypoint in the waypoint list. If this is zero, no waypoint will
        --be followed.
        FirstWaypoint: data int64.i;
        --A list of waypoints to follow
        WaypointList: data PathWaypoint.i {Data_Model::Data_Representation => Array;};
        --Describes the start time for this action, in scenario time. If this
        --field is zero, the action is completed immediately.
        StartTime: data int64.i;
        --Describes the end time for this action, in scenario time. If this
        --field is zero, it should be ignored, otherwise The entity will travel
        --until the stop time is reached.
        StopTime: data int64.i;
        --Describes how the entity should treat the end-of-path. Entities can
        --complete the path once, or continuously.
        RepeatMode: data TravelMode.i;
end FollowPathCommand.i;

data PathWaypoint extends Waypoint
end PathWaypoint;

--A waypoint that can be used as part of commanding entities' movement
data implementation PathWaypoint.i extends Waypoint.i
    subcomponents
        --The amount of time that an entity should pause before moving to the
        --next waypoint.
        PauseTime: data int64.i;
end PathWaypoint.i;

data StopMovementAction extends VehicleAction
end StopMovementAction;

--Tells the Entity to stop at the given location. If the location is
--null, then the entity will stop immediately.
data implementation StopMovementAction.i extends VehicleAction.i
    subcomponents
        --A location at which the entity should stop. If this is null, the
        --entity will stop immediately.
        Location: data Location3D.i;
end StopMovementAction.i;

data WaypointTransfer
end WaypointTransfer;

--Handles the transfer of waypoints. This does not affect the current
--navigation of the aircraft. This can be used to transfer, or request
--the transfer of, waypoints.
data implementation WaypointTransfer.i
    subcomponents
        --ID of the entity assoicated with the waypoints
        EntityID: data int64.i;
        --A list of wayppoints to transfer. This may be empty if the transfer
        --type is "RequestWaypoints" or "ClearWaypoints"
        Waypoints: data Waypoint.i {Data_Model::Data_Representation => Array;};
        --describes the transfer action to take
        TransferMode: data WaypointTransferMode.i;
end WaypointTransfer.i;

data PayloadStowAction
end PayloadStowAction;

--Commands a payload to stow.
data implementation PayloadStowAction.i
    subcomponents
        --payload to stow
        PayloadID: data int64.i;
end PayloadStowAction.i;

data WavelengthBand extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --Other or undefined wavelength band
            "AllAny",
            --Other or undefined wavelength band
            "EO",
            --Other or undefined wavelength band
            "LWIR",
            --Other or undefined wavelength band
            "SWIR",
            --Other or undefined wavelength band
            "MWIR",
            --Other or undefined wavelength band
            "Other");
end WavelengthBand;

data implementation WavelengthBand.i
end WavelengthBand.i;

data NavigationMode extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --lost comm, vehicle is out of comm range and should be executing
            --lost-comm behavior
            "Waypoint",
            --lost comm, vehicle is out of comm range and should be executing
            --lost-comm behavior
            "Loiter",
            --lost comm, vehicle is out of comm range and should be executing
            --lost-comm behavior
            "FlightDirector",
            --lost comm, vehicle is out of comm range and should be executing
            --lost-comm behavior
            "TargetTrack",
            --lost comm, vehicle is out of comm range and should be executing
            --lost-comm behavior
            "FollowLeader",
            --lost comm, vehicle is out of comm range and should be executing
            --lost-comm behavior
            "LostComm");
end NavigationMode;

data implementation NavigationMode.i
end NavigationMode.i;

data FOVOperationMode extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --field of view can only be set to certian, discrete values
            "Continuous",
            --field of view can only be set to certian, discrete values
            "Discrete");
end FOVOperationMode;

data implementation FOVOperationMode.i
end FOVOperationMode.i;

data GimbalPointingMode extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --indicates that the gimbal is stowed
            "Unknown",
            --indicates that the gimbal is stowed
            "AirVehicleRelativeAngle",
            --indicates that the gimbal is stowed
            "AirVehicleRelativeSlewRate",
            --indicates that the gimbal is stowed
            "LatLonSlaved",
            --indicates that the gimbal is stowed
            "InertialRelativeSlewRate",
            --indicates that the gimbal is stowed
            "Scan",
            --indicates that the gimbal is stowed
            "Stowed");
end GimbalPointingMode;

data implementation GimbalPointingMode.i
end GimbalPointingMode.i;

data ZoneAvoidanceType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --zone defines an area that is sensitive to visual detection. The
            --threshold of visual detection is not defined by this standard.
            "Physical",
            --zone defines an area that is sensitive to visual detection. The
            --threshold of visual detection is not defined by this standard.
            "Regulatory",
            --zone defines an area that is sensitive to visual detection. The
            --threshold of visual detection is not defined by this standard.
            "Acoustic",
            --zone defines an area that is sensitive to visual detection. The
            --threshold of visual detection is not defined by this standard.
            "Threat",
            --zone defines an area that is sensitive to visual detection. The
            --threshold of visual detection is not defined by this standard.
            "Visual");
end ZoneAvoidanceType;

data implementation ZoneAvoidanceType.i
end ZoneAvoidanceType.i;

data LoiterType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --Hovering.
            "VehicleDefault",
            --Hovering.
            "Circular",
            --Hovering.
            "Racetrack",
            --Hovering.
            "FigureEight",
            --Hovering.
            "Hover");
end LoiterType;

data implementation LoiterType.i
end LoiterType.i;

data LoiterDirection extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --clockwise
            "VehicleDefault",
            --clockwise
            "CounterClockwise",
            --clockwise
            "Clockwise");
end LoiterDirection;

data implementation LoiterDirection.i
end LoiterDirection.i;

data ServiceStatusType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --error from automation service
            "Information",
            --error from automation service
            "Warning",
            --error from automation service
            "Error");
end ServiceStatusType;

data implementation ServiceStatusType.i
end ServiceStatusType.i;

data SimulationStatusType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --simulation is reset
            "Stopped",
            --simulation is reset
            "Running",
            --simulation is reset
            "Paused",
            --simulation is reset
            "Reset");
end SimulationStatusType;

data implementation SimulationStatusType.i
end SimulationStatusType.i;

data SpeedType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --groundspeed
            "Airspeed",
            --groundspeed
            "Groundspeed");
end SpeedType;

data implementation SpeedType.i
end SpeedType.i;

data TurnType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --fly over, return to track
            "TurnShort",
            --fly over, return to track
            "FlyOver");
end TurnType;

data implementation TurnType.i
end TurnType.i;

data CommandStatusType extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --Cancelled by an operator, aircraft, or other entity
            "Pending",
            --Cancelled by an operator, aircraft, or other entity
            "Approved",
            --Cancelled by an operator, aircraft, or other entity
            "InProcess",
            --Cancelled by an operator, aircraft, or other entity
            "Executed",
            --Cancelled by an operator, aircraft, or other entity
            "Cancelled");
end CommandStatusType;

data implementation CommandStatusType.i
end CommandStatusType.i;

data TravelMode extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --Upon reaching the end of a route, the entity travels to the first
            --point and repeats the route.
            "SinglePass",
            --Upon reaching the end of a route, the entity travels to the first
            --point and repeats the route.
            "ReverseCourse",
            --Upon reaching the end of a route, the entity travels to the first
            --point and repeats the route.
            "Loop");
end TravelMode;

data implementation TravelMode.i
end TravelMode.i;

data WaypointTransferMode extends Base_Types::Integer
    properties
        Data_Model::Enumerators => (
            --Reports waypoints that are curretly in the aircraft computer
            "RequestWaypoints",
            --Reports waypoints that are curretly in the aircraft computer
            "AddWaypoints",
            --Reports waypoints that are curretly in the aircraft computer
            "ClearWaypoints",
            --Reports waypoints that are curretly in the aircraft computer
            "ReportWaypoints");
end WaypointTransferMode;

data implementation WaypointTransferMode.i
end WaypointTransferMode.i;

end CMASI;